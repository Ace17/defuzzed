#!/usr/bin/env rdmd
/**
 * @brief Generate a random D (valid) source file
 * @author Sebastien Alaiwan
 * @date 2016-04-02
 */

/*
 * Copyright (C) 2016 - Sebastien Alaiwan
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This file is part of defuzzed, a fuzzer for D compilers;
 */

import std.string;
import std.stdio;
import std.conv;
import std.random : unpredictableSeed, Random;

int main(string[] args)
{
  auto seed = unpredictableSeed;
  if(args.length > 1)
    seed = to!int(args[1]);
  string outputPath = "-";
  if(args.length > 2)
    outputPath = args[2];

  auto f = openOutput(outputPath);

  generateRandomSourceFile(seed, f);

  return 0;
}

File openOutput(string path)
{
  if(path == "-")
    return stdout;
  else
    return File(path, "w");
}

void generateRandomSourceFile(int seed, File f)
{
  f.writefln("// generated by defuzzed, seed %s", seed);

  gen.seed(seed);

  generateDeclarations(f);
}

void generateDeclarations(File f)
{
  const numDecls = randomCount();

  for(int i=0;i < numDecls; ++i)
    generateDeclaration(f);
}

void generateDeclaration(File f)
{
  if(uniform(0, 2))
    generateClass(f);
  else
    generateFunction(f);
}

void generateClass(File f)
{
  f.writefln("class %s", allocName());

  f.writefln("{");
  generateDeclarations(f);
  f.writefln("}");
}

void generateFunction(File f)
{
  const name = allocName();

  functionNames ~= name;

  f.writefln("void %s()", name);

  f.writefln("{");
  generateStatements(f);
  generateDeclarations(f);
  f.writefln("}");
}

void generateStatements(File f)
{
  const N = randomCount();

  for(int i=0;i < N; ++i)
    generateStatement(f);
}

void generateStatement(File f)
{
  immutable genFuncs =
    [
    &generateFunctionCall,
    &generateVarDecl,
    ];

  auto generator = genFuncs[uniform(0, cast(int)$)];
  generator(f);
}

void generateFunctionCall(File f)
{
  const name = lookupRandomFunction();
  f.writefln("%s();", name);
}

void generateVarDecl(File f)
{
  const name = allocName();
  f.writef("int %s", name);
  if(varNames.length > 0 && uniform(0, 3))
  {
    f.writef(" = %s", varNames[uniform(0, $)]);
  }
  f.writeln(";");

  varNames ~= name;
}

///////////////////////////////////////////////////////////////////////////////
// generated program environment

string[] varNames;
string[] functionNames;

struct Function
{
  int numArgs;
}

string lookupRandomFunction()
{
  return functionNames[uniform(0, $)];
}

string allocName()
{
  static int id;
  ++id;
  return format("i%s", id++);
}

///////////////////////////////////////////////////////////////////////////////
// random

Random gen;

int numItems = 50; // desired program size (approximative)

int uniform(int min, long max)
{
  return std.random.uniform(min, cast(int)max, gen);
}

int randomCount()
{
  if(numItems <= 0)
    return 0;

  const N = uniform(1, 10);
  numItems -= N;
  return N;
}

